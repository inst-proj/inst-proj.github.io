---
title: Рекурсия, стек
layout: base
permalink: /js-dir/recursion-stack/
---
{% include header.html %}

<section class="section-syntax">
	<div class="container">
		<div class="row justify-content-center">
			<div class="col-10">
				<h1 class="section-syntax__head">
					{{ page.title }}
				</h1>
				<div class="section-syntax__content">
					<p>В теле функции могут быть вызваны другие функции для выполнения подзадач.</p>
					<p>Частный случай подвызова – когда функция вызывает сама себя. Это называется <em>рекурсией</em>.</p>
					<p>Рекурсия используется для ситуаций, когда выполнение одной сложной задачи можно представить как некое действие в совокупности с решением той же задачи в более простом варианте.</p>
					<p>Сейчас мы посмотрим примеры.</p>
					<p>Рекурсия – общая тема программирования, не относящаяся напрямую к JavaScript. Если вы разрабатывали на других языках или изучали программирование раньше в ВУЗе, то наверняка уже знаете, что это такое.</p>
					<p>Эта глава предназначена для читателей, которые пока с этой темой незнакомы и хотят лучше разобраться в том, как работают функции.</p>
					<h2>Степень pow(x, n) через рекурсию</h2><p>В качестве первого примера использования рекурсивных вызовов – рассмотрим задачу возведения числа <code>x</code> в натуральную степень <code>n</code>.</p>
					<p>Её можно представить как совокупность более простого действия и более простой задачи того же типа вот так:</p>
					
					<div class="flex-center">
						<img src="/images/js/18.1.png" alt="Степень pow(x, n) через рекурсию">
					</div>
					
					<p>То есть, <code>x<sup>n</sup> = x * x<sup>n-1</sup></code>.</p>
					<p>Например, вычислим <code>pow(2, 4)</code>, последовательно переходя к более простой задаче:</p>
					<ol>
					<li><code>pow(2, 4) = 2 * pow(2, 3)</code></li>
					<li><code>pow(2, 3) = 2 * pow(2, 2)</code></li>
					<li><code>pow(2, 2) = 2 * pow(2, 1)</code></li>
					<li><code>pow(2, 1) = 2</code></li>
					</ol>
					<p>На шаге 1 нам нужно вычислить <code>pow(2,3)</code>, поэтому мы делаем шаг 2, дальше нам нужно <code>pow(2,2)</code>, мы делаем шаг 3, затем шаг 4, и на нём уже можно остановиться, ведь очевидно, что результат возведения числа в степень 1 – равен самому числу.</p>
					<p>Далее, имея результат на шаге 4, он подставляется обратно в шаг 3, затем имеем <code>pow(2,2)</code> – подставляем в шаг 2 и на шаге 1 уже получаем результат.</p>
					<p>Этот алгоритм на JavaScript:</p>
					
					<div class="flex-center">
						<img src="/images/js/18.2.png" alt="Степень pow(x, n) через рекурсию">
					</div>
					
					<p>Говорят, что «функция <code>pow</code> <em>рекурсивно вызывает сама себя</em>» до <code>n == 1</code>.</p>
					<p>Значение, на котором рекурсия заканчивается, называют <em>базисом рекурсии</em>. В примере выше базисом является <code>1</code>.</p>
					<p>Общее количество вложенных вызовов называют <em>глубиной рекурсии</em>. В случае со степенью, всего будет <code>n</code> вызовов.</p>
					<p>Максимальная глубина рекурсии в браузерах ограничена, точно можно рассчитывать на <code>10000</code> вложенных вызовов, но некоторые интерпретаторы допускают и больше.</p>
					<p>Итак, рекурсию используют, когда вычисление функции можно свести к её более простому вызову, а его – ещё к более простому, и так далее, пока значение не станет очевидно.</p>
					<h2>Контекст выполнения, стек</h2><p>Теперь мы посмотрим, как работают рекурсивные вызовы. Для этого мы рассмотрим, как вообще работают функции, что происходит при вызове.</p>
					<p><strong>У каждого вызова функции есть свой «контекст выполнения» (execution context).</strong></p>
					<p>Контекст выполнения – это служебная информация, которая соответствует текущему запуску функции. Она включает в себя локальные переменные функции и конкретное место в коде, на котором находится интерпретатор.</p>
					<p>Например, для вызова <code>pow(2, 3)</code> из примера выше будет создан контекст выполнения, который будет хранить переменные <code>x = 2, n = 3</code>. Мы схематично обозначим его так:</p>
					<ul class="function-execution-context">
						<li>Контекст: { x: 2, n: 3, строка 1 }</li>
					</ul>
					<p>Далее функция <code>pow</code> начинает выполняться. Вычисляется выражение <code>n != 1</code> – оно равно <code>true</code>, ведь в текущем контексте <code>n=3</code>. Поэтому задействуется первая ветвь <code>if</code> :</p>
					
					<div class="flex-center">
						<img src="/images/js/18.3.png" alt="Контекст выполнения, стек">
					</div>
					
					<p>Чтобы вычислить выражение <code>x * pow(x, n-1)</code>, требуется произвести запуск <code>pow</code> с новыми аргументами.</p>
					<p><strong>При любом вложенном вызове JavaScript запоминает текущий контекст выполнения в специальной внутренней структуре данных – «стеке контекстов».</strong></p>
					<p>Затем интерпретатор приступает к выполнению вложенного вызова.</p>
					<p>В данном случае вызывается та же <code>pow</code>, однако это абсолютно неважно. Для любых функций процесс одинаков.</p>
					<p>Для нового вызова создаётся свой контекст выполнения, и управление переходит в него, а когда он завершён – старый контекст достаётся из стека и выполнение внешней функции возобновляется.</p>
					<p>Разберём происходящее с контекстами более подробно, начиная с вызова <code>(*)</code>:</p>
					
					<div class="flex-center">
						<img src="/images/js/18.4.png" alt="Контекст выполнения, стек">
					</div>

					<dl>
					<dt><code>pow(2, 3)</code></dt>
					<dd>
					<p>Запускается функция <code>pow</code>, с аргументами <code>x=2</code>, <code>n=3</code>. Эти переменные хранятся в контексте выполнения, схематично изображённом ниже:</p>
						<ul class="function-execution-context">
						<li>Контекст: { x: 2, n: 3, строка 1 }</li>
						</ul>
						Выполнение в этом контексте продолжается, пока не встретит вложенный вызов в строке 3.
					</dd>
					<dt><code>pow(2, 2)</code></dt>
					<dd>
					<p>В строке <code>3</code> происходит вложенный вызов <code>pow</code> с аргументами <code>x=2</code>, <code>n=2</code>. Текущий контекст сохраняется в стеке, а для вложеннного вызова создаётся новый контекст (выделен жирным ниже):</p>
						<ul class="function-execution-context">
						<li>Контекст: { x: 2, n: 3, строка 3 }</li>
						<li>Контекст: { x: 2, n: 2, строка 1 }</li>
						</ul>
						Обратим внимание, что контекст включает в себя не только переменные, но и место в коде, так что когда вложенный вызов завершится -- можно будет легко вернуться назад.
					<p>Слово «строка» здесь условно, на самом деле, конечно, запомнено более точное место в цепочке команд.</p>
					</dd>
					<dt><code>pow(2, 1)</code></dt>
					<dd>
					<p>Опять вложенный вызов в строке <code>3</code>, на этот раз – с аргументами <code>x=2</code>, <code>n=1</code>. Создаётся новый текущий контекст, предыдущий добавляется в стек:</p>
						<ul class="function-execution-context">
						<li>Контекст: { x: 2, n: 3, строка 3 }</li>
						<li>Контекст: { x: 2, n: 2, строка 3 }</li>
						<li>Контекст: { x: 2, n: 1, строка 1 }</li>
						</ul>
						На текущий момент в стеке уже два старых контекста.
					</dd>
					<dt>Выход из <code>pow(2, 1)</code>.</dt>
					<dd>
					<p>При выполнении <code>pow(2, 1)</code>, в отличие от предыдущих запусков, выражение <code>n != 1</code> будет равно <code>false</code>, поэтому  сработает вторая ветка <code>if..else</code>:</p>
					
					<div class="flex-center">
						<img src="/images/js/18.5.png" alt="Контекст выполнения, стек">
					</div>
					
					<p>Здесь вложенных вызовов нет, так что функция заканчивает свою работу, возвращая <code>2</code>. Текущий контекст больше не нужен и удаляется из памяти, из стека восстанавливается предыдущий:</p>
						<ul class="function-execution-context">
						<li>Контекст: { x: 2, n: 3, строка 3 }</li>
						<li>Контекст: { x: 2, n: 2, строка 3 }</li>
						</ul>
						Возобновляется обработка внешнего вызова `pow(2, 2)`.
					</dd>
					<dt>Выход из <code>pow(2, 2)</code>.</dt>
					<dd>
					<p>…И теперь уже <code>pow(2, 2)</code> может закончить свою работу, вернув <code>4</code>. Восстанавливается контекст предыдущего вызова:</p>
						<ul class="function-execution-context">
						<li>Контекст: { x: 2, n: 3, строка 3 }</li>
						</ul>
						Возобновляется обработка внешнего вызова `pow(2, 3)`.
					</dd>
					<dt>Выход из <code>pow(2, 3)</code>.</dt>
					<dd>
					<p>Самый внешний вызов заканчивает свою работу, его результат: <code>pow(2, 3) = 8</code>.</p>
					<p>Глубина рекурсии в данном случае составила: <strong>3</strong>.</p>
					</dd>
					</dl>
					<p>Как видно из иллюстраций выше, глубина рекурсии равна максимальному числу контекстов, одновременно хранимых в стеке.</p>
					<p>Обратим внимание на требования к памяти. Рекурсия приводит к хранению всех данных для неоконченных внешних вызовов в стеке, в данном случае это приводит к тому, что возведение в степень <code>n</code> хранит в памяти <code>n</code> различных контекстов.</p>
					<p>Реализация возведения в степень через цикл гораздо более экономна:</p>
					
					<div class="flex-center">
						<img src="/images/js/18.6.png" alt="Контекст выполнения, стек">
					</div>
					
					<p>У такой функции <code>pow</code> будет один контекст, в котором будут последовательно меняться значения <code>i</code> и <code>result</code>.</p>
					<p><strong>Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.</strong></p>
					<p>Но переделка рекурсии в цикл может быть нетривиальной, особенно когда в функции, в зависимости от условий, используются различные рекурсивные подвызовы, когда ветвление более сложное.</p>
					<h2>Итого</h2><p>Рекурсия – это когда функция вызывает сама себя, как правило, с другими аргументами.</p>
					<p>Существуют много областей применения рекурсивных вызовов. Здесь мы посмотрели на один из них – решение задачи путём сведения её к более простой (с меньшими аргументами), но также рекурсия используется для работы с «естественно рекурсивными» структурами данных, такими как HTML-документы, для «глубокого» копирования сложных объектов.</p>
				</div>
			</div>
		</div>
	</div>
</section>