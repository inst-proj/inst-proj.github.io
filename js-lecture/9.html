---
title: Операторы сравнения и логические значения
layout: base
permalink: /js-dir/comparison-&-boolean/
---

<section class="section-syntax">
	<div class="container">
		<div class="row justify-content-center">
			<div class="col-10">
				<h1 class="section-syntax__head">
					{{ page.title }}
				</h1>
				<div class="section-syntax__content">
					<p>В этом разделе мы познакомимся с операторами сравнения и с логическими значениями, которые такие операторы возвращают.</p>
					<p>Многие операторы сравнения знакомы нам из математики:</p>
					<ul>
					<li>Больше/меньше: <code>a &gt; b</code>, <code>a &lt; b</code>.</li>
					<li>Больше/меньше или равно: <code>a &gt;= b</code>, <code>a &lt;= b</code>.</li>
					<li>Равно <code>a == b</code>.
					Для сравнения используется два символа равенства <code>'='</code>. Один символ <code>a = b</code> означал бы присваивание.</li>
					<li>«Не равно». В математике он пишется как <code>≠</code>, в JavaScript – знак равенства с восклицательным знаком перед ним <code>!=</code>.</li>
					</ul>
					<h2>Логические значения</h2><p>Как и другие операторы, сравнение возвращает значение. Это значение имеет <em>логический</em> тип.</p>
					<p>Существует всего два логических значения:</p>
					<ul>
					<li><code>true</code> – имеет смысл «да», «верно», «истина».</li>
					<li><code>false</code> – означает «нет», «неверно», «ложь».</li>
					</ul>
					<p>Например:</p>
					
					<div class="flex-center">
						<img src="/images/js/9.1.png" alt="true false">
					</div>
					
					<p>Логические значения можно использовать и напрямую, присваивать переменным, работать с ними как с любыми другими:</p>
					
					<div class="flex-center">
						<img src="/images/js/9.2.png" alt="true false">
					</div>
						
					<h2>Сравнение строк</h2><p>Строки сравниваются побуквенно:</p>
					
					<div class="flex-center">
						<img src="/images/js/9.3.png" alt="сравнение строк">
					</div>
					
					<div class="important important_warn">
						<div class="important__header"><span class="important__type">Осторожно, Unicode!</span></div>
						<div class="important__content"><p>Аналогом «алфавита» во внутреннем представлении строк служит кодировка, у каждого символа – свой номер (код). JavaScript использует кодировку <a href="http://ru.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4">Unicode</a>.</p>
					<p>При этом сравниваются <em>численные коды символов</em>. В частности, код у символа <code>Б</code> больше, чем у <code>А</code>, поэтому и результат сравнения такой.</p>
					<p><strong>В кодировке Unicode обычно код у строчной буквы больше, чем у прописной.</strong></p>
					<p>Поэтому регистр имеет значение:</p>
					
					<div class="flex-center">
						<img src="/images/js/9.4.png" alt="true false">
					</div>
					
					<p>Для корректного сравнения символы должны быть в одинаковом регистре.</p>
					</div></div>
					<p>Если строка состоит из нескольких букв, то сравнение осуществляется как в телефонной книжке или в словаре. Сначала сравниваются первые буквы, потом вторые, и так далее, пока одна не будет больше другой.</p>
					<p>Иными словами, больше – та строка, которая в телефонной книге была бы на большей странице.</p>
					<p>Например:</p>
					<ul>
					<li>
					<p>Если первая буква первой строки больше – значит первая строка больше, независимо от остальных символов:</p>
					
					<div class="flex-center">
						<img src="/images/js/9.5.png" alt="true">
					</div>
				
					</li>
					<li>
					<p>Если одинаковы – сравнение идёт дальше. Здесь оно дойдёт до третьей буквы:</p>
					
					<div class="flex-center">
						<img src="/images/js/9.6.png" alt="сравнение">
					</div>

				</li>
					<li>
					<p>При этом любая буква больше отсутствия буквы:</p>
					
					<div class="flex-center">
						<img src="/images/js/9.7.png" alt="true">
					</div>
				
				</li>
					</ul>
					<p>Такое сравнение называется <em>лексикографическим</em>.</p>
					<div class="important important_warn">
						<div class="important__header"><span class="important__type">Важно:</span></div>
						<div class="important__content"><p>Обычно мы получаем значения от посетителя в виде строк. Например, <code>prompt</code> возвращает <em>строку</em>, которую ввел посетитель.</p>
					<p>Числа, полученные таким образом, в виде строк сравнивать нельзя, результат будет неверен. Например:</p>
					
					<div class="flex-center">
						<img src="/images/js/9.8.png" alt="true false">
					</div>
					
					<p>В примере выше <code>2</code> оказалось больше <code>14</code>, потому что строки сравниваются посимвольно, а первый символ <code>'2'</code> больше <code>'1'</code>.</p>
					<p>Правильно было бы преобразовать их к числу явным образом. Например, поставив перед ними <code>+</code>:</p>
					
					<div class="flex-center">
						<img src="/images/js/9.9.png" alt="+">
					</div>
				
				</div></div>
					<h2>Сравнение разных типов</h2><p>При сравнении значений разных типов, используется числовое преобразование. Оно применяется к обоим значениям.</p>
					<p>Например:</p>
					
					<div class="flex-center">
						<img src="/images/js/9.10.png" alt="Сравнение разных типов">
					</div>
					
					<p>Тема преобразований типов будет продолжена далее, в главе <a href="/types-conversion">Преобразование типов для примитивов</a>.</p>
					<h2>Строгое равенство</h2><p>В обычном операторе <code>==</code> есть «проблема» – он не может отличить <code>0</code> от <code>false</code>:</p>
					
					<div class="flex-center">
						<img src="/images/js/9.11.png" alt="строгое равенство">
					</div>
					
					<p>Та же ситуация с пустой строкой:</p>
					
					<div class="flex-center">
						<img src="/images/js/9.12.png" alt="пустая строка">
					</div>
					
					<p>Это естественное следствие того, что операнды разных типов преобразовались к числу. Пустая строка, как и <code>false</code>, при преобразовании к числу дают <code>0</code>.</p>
					<p>Что же делать, если всё же нужно отличить <code>0</code> от <code>false</code>?</p>
					<p><strong>Для проверки равенства без преобразования типов используются операторы строгого равенства <code>===</code> (тройное равно) и <code>!==</code>.</strong></p>
					<p>Если тип разный, то они всегда возвращают <code>false</code>:</p>
					
					<div class="flex-center">
						<img src="/images/js/9.13.png" alt="false">
					</div>
					
					<p>Строгое сравнение предпочтительно, если мы хотим быть уверены, что «сюрпризов» не будет.</p>
					<h2>Сравнение с null и undefined</h2><p>Проблемы со специальными значениями возможны, когда к переменной применяется операция сравнения <code>&gt; &lt; &lt;= &gt;=</code>, а у неё может быть как численное значение, так и <code>null/undefined</code>.</p>
					<p><strong>Интуитивно кажется, что <code>null/undefined</code> эквивалентны нулю, но это не так.</strong></p>
					<p>Они ведут себя по-другому.</p>
					<ol>
					<li>Значения <code>null</code> и <code>undefined</code> равны <code>==</code> друг другу и не равны чему бы то ни было ещё.
					Это жёсткое правило буквально прописано в спецификации языка.</li>
					<li>При преобразовании в число <code>null</code> становится <code>0</code>, а <code>undefined</code> становится <code>NaN</code>.</li>
					</ol>
					<p>Посмотрим забавные следствия.</p>
					<h3>Некорректный результат сравнения null с 0</h3><p>Сравним <code>null</code> с нулём:</p>
					
					<div class="flex-center">
						<img src="/images/js/9.14.png" alt="Некорректный результат сравнения null с 0">
					</div>
						
						<p>Итак, мы получили, что <code>null</code> не больше и не равен нулю. А теперь…</p>
						
					<div class="flex-center">
						<img src="/images/js/9.15.png" alt="null">
					</div>
							
							<p>Как такое возможно? Если нечто <em>«больше или равно нулю»</em>, то резонно полагать, что оно либо <em>больше</em>, либо <em>равно</em>. Но здесь это не так.</p>
					<p>Дело в том, что алгоритмы проверки равенства <code>==</code> и сравнения <code>&gt;= &gt; &lt; &lt;=</code> работают по-разному.</p>
					<p>Сравнение честно приводит к числу, получается ноль. А при проверке равенства значения <code>null</code> и <code>undefined</code> обрабатываются особым образом: они равны друг другу, но не равны чему-то ещё.</p>
					<p>В результате получается странная с точки зрения здравого смысла ситуация, которую мы видели в примере выше.</p>
					<h3>Несравнимый undefined</h3><p>Значение <code>undefined</code> вообще нельзя сравнивать:</p>
					
					<div class="flex-center">
						<img src="/images/js/9.16.png" alt="undefined">
					</div>

					<ul>
					<li>Сравнения <code>(1)</code> и <code>(2)</code> дают <code>false</code> потому, что <code>undefined</code> при преобразовании к числу даёт <code>NaN</code>. А значение <code>NaN</code> по стандарту устроено так, что сравнения <code>==</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> и даже <code>===</code> с ним возвращают <code>false</code>.</li>
					<li>Проверка равенства <code>(3)</code> даёт <code>false</code>, потому что в стандарте явно прописано, что <code>undefined</code> равно лишь <code>null</code> или себе и ничему другому.</li>
					</ul>
					<p><strong>Вывод: любые сравнения с <code>undefined/null</code>, кроме точного <code>===</code>, следует делать с осторожностью.</strong></p>
					<p>Желательно не использовать сравнения <code>&gt;= &gt; &lt; &lt;=</code> с ними, во избежание ошибок в коде.</p>
					<h2>Итого</h2><ul>
					<li>В JavaScript есть логические значения <code>true</code> (истина) и <code>false</code> (ложь). Операторы сравнения возвращают их.</li>
					<li>Строки сравниваются побуквенно.</li>
					<li>Значения разных типов приводятся к числу при сравнении, за исключением строгого равенства <code>===</code> (<code>!==</code>).</li>
					<li>Значения <code>null</code> и <code>undefined</code> равны <code>==</code> друг другу и не равны ничему другому. В других сравнениях (с участием <code>&gt;</code>,<code>&lt;</code>) их лучше не использовать, так как они ведут себя не как <code>0</code>.</li>
					</ul>
					<p>Мы ещё вернёмся к теме сравнения позже, когда лучше изучим различные типы данных в JavaScript.</p>
				</div>
			</div>
		</div>
	</div>
</section>